<<<<<<< HEAD
declare class Fraction {
  constructor();
  constructor(num: Fraction.FractionInput);
  constructor(numerator: number | bigint, denominator: number | bigint);

  s: bigint;
  n: bigint;
  d: bigint;
=======
declare module 'Fraction';

export interface NumeratorDenominator {
  n: number;
  d: number;
}

type FractionConstructor = {
  (fraction: Fraction): Fraction;
  (num: number | string): Fraction;
  (numerator: number, denominator: number): Fraction;
  (numbers: [number | string, number | string]): Fraction;
  (fraction: NumeratorDenominator): Fraction;
  (firstValue: Fraction | number | string | [number | string, number | string] | NumeratorDenominator, secondValue?: number): Fraction;
};

export default class Fraction {
  constructor (fraction: Fraction);
  constructor (num: number | string);
  constructor (numerator: number, denominator: number);
  constructor (numbers: [number | string, number | string]);
  constructor (fraction: NumeratorDenominator);
  constructor (firstValue: Fraction | number | string | [number | string, number | string] | NumeratorDenominator, secondValue?: number);

  s: number;
  n: number;
  d: number;
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)

  abs(): Fraction;
  neg(): Fraction;

<<<<<<< HEAD
  add: Fraction.FractionParam;
  sub: Fraction.FractionParam;
  mul: Fraction.FractionParam;
  div: Fraction.FractionParam;
  pow: Fraction.FractionParam;
  log: Fraction.FractionParam;
  gcd: Fraction.FractionParam;
  lcm: Fraction.FractionParam;

  mod(): Fraction;
  mod(num: Fraction.FractionInput): Fraction;
=======
  add: FractionConstructor;
  sub: FractionConstructor;
  mul: FractionConstructor;
  div: FractionConstructor;
  pow: FractionConstructor;
  gcd: FractionConstructor;
  lcm: FractionConstructor;
  
  mod(n?: number | string | Fraction): Fraction;
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)

  ceil(places?: number): Fraction;
  floor(places?: number): Fraction;
  round(places?: number): Fraction;
<<<<<<< HEAD
  roundTo: Fraction.FractionParam;

  inverse(): Fraction;
  simplify(eps?: number): Fraction;

  equals(num: Fraction.FractionInput): boolean;
  lt(num: Fraction.FractionInput): boolean;
  lte(num: Fraction.FractionInput): boolean;
  gt(num: Fraction.FractionInput): boolean;
  gte(num: Fraction.FractionInput): boolean;
  compare(num: Fraction.FractionInput): number;
  divisible(num: Fraction.FractionInput): boolean;

  valueOf(): number;
  toString(decimalPlaces?: number): string;
  toLatex(showMixed?: boolean): string;
  toFraction(showMixed?: boolean): string;
  toContinued(): bigint[];
  clone(): Fraction;

  static default: typeof Fraction;
  static Fraction: typeof Fraction;
}

declare namespace Fraction {
  interface NumeratorDenominator { n: number | bigint; d: number | bigint; }
  type FractionInput =
    | Fraction
    | number
    | bigint
    | string
    | [number | bigint | string, number | bigint | string]
    | NumeratorDenominator;

  type FractionParam = {
    (numerator: number | bigint, denominator: number | bigint): Fraction;
    (num: FractionInput): Fraction;
  };
}

/**
 * Export matches CJS runtime:
 *   module.exports = Fraction;
 *   module.exports.default  = Fraction;
 *   module.exports.Fraction = Fraction;
 */
declare const FractionExport: typeof Fraction & {
  default: typeof Fraction;
  Fraction: typeof Fraction;
};

export = FractionExport;
=======

  inverse(): Fraction;
  
  simplify(eps?: number): Fraction;
  
  equals(n: number | string | Fraction): boolean;
  compare(n: number | string | Fraction): number;
  divisible(n: number | string | Fraction): boolean;
  
  valueOf(): number;
  toString(decimalPlaces?: number): string;
  toLatex(excludeWhole?: boolean): string;
  toFraction(excludeWhole?: boolean): string;
  toContinued(): number[];
  clone(): Fraction;
}
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)
