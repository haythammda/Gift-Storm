<<<<<<< HEAD
import { timeoutManager } from './timeoutManager'
import { isServer, isValidTimeout } from './utils'
import type { ManagedTimerId } from './timeoutManager'

export abstract class Removable {
  gcTime!: number
  #gcTimeout?: ManagedTimerId
=======
import { isServer, isValidTimeout } from './utils'

export abstract class Removable {
  gcTime!: number
  #gcTimeout?: ReturnType<typeof setTimeout>
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)

  destroy(): void {
    this.clearGcTimeout()
  }

  protected scheduleGc(): void {
    this.clearGcTimeout()

    if (isValidTimeout(this.gcTime)) {
<<<<<<< HEAD
      this.#gcTimeout = timeoutManager.setTimeout(() => {
=======
      this.#gcTimeout = setTimeout(() => {
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)
        this.optionalRemove()
      }, this.gcTime)
    }
  }

  protected updateGcTime(newGcTime: number | undefined): void {
    // Default to 5 minutes (Infinity for server-side) if no gcTime is set
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1000),
    )
  }

  protected clearGcTimeout() {
    if (this.#gcTimeout) {
<<<<<<< HEAD
      timeoutManager.clearTimeout(this.#gcTimeout)
=======
      clearTimeout(this.#gcTimeout)
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)
      this.#gcTimeout = undefined
    }
  }

  protected abstract optionalRemove(): void
}
