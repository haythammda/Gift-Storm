'use strict'

<<<<<<< HEAD
var extend = require('xtend/mutable')

=======
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)
module.exports = PostgresInterval

function PostgresInterval (raw) {
  if (!(this instanceof PostgresInterval)) {
    return new PostgresInterval(raw)
  }
<<<<<<< HEAD
  extend(this, parse(raw))
}
var properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years']
PostgresInterval.prototype.toPostgres = function () {
  var filtered = properties.filter(this.hasOwnProperty, this)
=======

  Object.assign(this, parse(raw))
}
const properties = ['seconds', 'minutes', 'hours', 'days', 'months', 'years']
PostgresInterval.prototype.toPostgres = function () {
  const filtered = properties.filter(key => Object.prototype.hasOwnProperty.call(this, key) && this[key] !== 0)
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)

  // In addition to `properties`, we need to account for fractions of seconds.
  if (this.milliseconds && filtered.indexOf('seconds') < 0) {
    filtered.push('seconds')
  }

  if (filtered.length === 0) return '0'
  return filtered
    .map(function (property) {
<<<<<<< HEAD
      var value = this[property] || 0
=======
      let value = this[property] || 0
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)

      // Account for fractional part of seconds,
      // remove trailing zeroes.
      if (property === 'seconds' && this.milliseconds) {
        value = (value + this.milliseconds / 1000).toFixed(6).replace(/\.?0+$/, '')
      }

      return value + ' ' + property
    }, this)
    .join(' ')
}

<<<<<<< HEAD
var propertiesISOEquivalent = {
=======
const propertiesISOEquivalent = {
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)
  years: 'Y',
  months: 'M',
  days: 'D',
  hours: 'H',
  minutes: 'M',
  seconds: 'S'
}
<<<<<<< HEAD
var dateProperties = ['years', 'months', 'days']
var timeProperties = ['hours', 'minutes', 'seconds']
// according to ISO 8601
PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function () {
  var datePart = dateProperties
    .map(buildProperty, this)
    .join('')

  var timePart = timeProperties
    .map(buildProperty, this)
    .join('')

  return 'P' + datePart + 'T' + timePart

  function buildProperty (property) {
    var value = this[property] || 0
=======
const dateProperties = ['years', 'months', 'days']
const timeProperties = ['hours', 'minutes', 'seconds']
// according to ISO 8601
PostgresInterval.prototype.toISOString = PostgresInterval.prototype.toISO = function () {
  return toISOString.call(this, { short: false })
}

PostgresInterval.prototype.toISOStringShort = function () {
  return toISOString.call(this, { short: true })
}

function toISOString ({ short = false }) {
  const datePart = dateProperties
    .map(buildProperty, this)
    .join('')

  const timePart = timeProperties
    .map(buildProperty, this)
    .join('')

  if (!timePart.length && !datePart.length) return 'PT0S'

  if (!timePart.length) return `P${datePart}`

  return `P${datePart}T${timePart}`

  function buildProperty (property) {
    let value = this[property] || 0
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)

    // Account for fractional part of seconds,
    // remove trailing zeroes.
    if (property === 'seconds' && this.milliseconds) {
      value = (value + this.milliseconds / 1000).toFixed(6).replace(/0+$/, '')
    }

<<<<<<< HEAD
=======
    if (short && !value) return ''

>>>>>>> parent of 82e7c980 (trying to back back before dimentios)
    return value + propertiesISOEquivalent[property]
  }
}

<<<<<<< HEAD
var NUMBER = '([+-]?\\d+)'
var YEAR = NUMBER + '\\s+years?'
var MONTH = NUMBER + '\\s+mons?'
var DAY = NUMBER + '\\s+days?'
var TIME = '([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?'
var INTERVAL = new RegExp([YEAR, MONTH, DAY, TIME].map(function (regexString) {
  return '(' + regexString + ')?'
})
  .join('\\s*'))

// Positions of values in regex match
var positions = {
  years: 2,
  months: 4,
  days: 6,
  hours: 9,
  minutes: 10,
  seconds: 11,
  milliseconds: 12
}
// We can use negative time
var negatives = ['hours', 'minutes', 'seconds', 'milliseconds']

function parseMilliseconds (fraction) {
  // add omitted zeroes
  var microseconds = fraction + '000000'.slice(fraction.length)
  return parseInt(microseconds, 10) / 1000
}

function parse (interval) {
  if (!interval) return {}
  var matches = INTERVAL.exec(interval)
  var isNegative = matches[8] === '-'
  return Object.keys(positions)
    .reduce(function (parsed, property) {
      var position = positions[property]
      var value = matches[position]
      // no empty string
      if (!value) return parsed
      // milliseconds are actually microseconds (up to 6 digits)
      // with omitted trailing zeroes.
      value = property === 'milliseconds'
        ? parseMilliseconds(value)
        : parseInt(value, 10)
      // no zeros
      if (!value) return parsed
      if (isNegative && ~negatives.indexOf(property)) {
        value *= -1
      }
      parsed[property] = value
      return parsed
    }, {})
}
=======
const NUMBER = '([+-]?\\d+)'
const YEAR = `${NUMBER}\\s+years?`
const MONTH = `${NUMBER}\\s+mons?`
const DAY = `${NUMBER}\\s+days?`
// NOTE: PostgreSQL automatically overflows seconds into minutes and minutes
// into hours, so we can rely on minutes and seconds always being 2 digits
// (plus decimal for seconds). The overflow stops at hours - hours do not
// overflow into days, so could be arbitrarily long.
const TIME = '([+-])?(\\d+):(\\d\\d):(\\d\\d(?:\\.\\d{1,6})?)'
const INTERVAL = new RegExp(
  '^\\s*' +
    // All parts of an interval are optional
    [YEAR, MONTH, DAY, TIME].map((str) => '(?:' + str + ')?').join('\\s*') +
    '\\s*$'
)

// All intervals will have exactly these properties:
const ZERO_INTERVAL = Object.freeze({
  years: 0,
  months: 0,
  days: 0,
  hours: 0,
  minutes: 0,
  seconds: 0,
  milliseconds: 0.0
})

function parse (interval) {
  if (!interval) {
    return ZERO_INTERVAL
  }

  const matches = INTERVAL.exec(interval) || []

  const [
    ,
    yearsString,
    monthsString,
    daysString,
    plusMinusTime,
    hoursString,
    minutesString,
    secondsString
  ] = matches

  const timeMultiplier = plusMinusTime === '-' ? -1 : 1

  const years = yearsString ? parseInt(yearsString, 10) : 0
  const months = monthsString ? parseInt(monthsString, 10) : 0
  const days = daysString ? parseInt(daysString, 10) : 0
  const hours = hoursString ? timeMultiplier * parseInt(hoursString, 10) : 0
  const minutes = minutesString
    ? timeMultiplier * parseInt(minutesString, 10)
    : 0
  const secondsFloat = parseFloat(secondsString) || 0
  // secondsFloat is guaranteed to be >= 0, so floor is safe
  const absSeconds = Math.floor(secondsFloat)
  const seconds = timeMultiplier * absSeconds
  // Without the rounding, we end up with decimals like 455.99999999999994 instead of 456
  const milliseconds = Math.round(timeMultiplier * (secondsFloat - absSeconds) * 1000000) / 1000
  return {
    years,
    months,
    days,
    hours,
    minutes,
    seconds,
    milliseconds
  }
}
PostgresInterval.parse = parse
>>>>>>> parent of 82e7c980 (trying to back back before dimentios)
